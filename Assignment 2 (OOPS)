# Que 1: Explain the importance of functions.
Functions are blocks of reusable and organised code that usually perform a single, related action. 
They are a crucial part of programming because they save you a lot of time and make the code cleaner.
It eliminates redudancy and make larger code more efficient and easier to maintain.

# Que 2: Write a basic function to greet a student.
def _my_func_greet():
  print("Hello , Welcome to PW Skills Assignment 2" + "\n"+"Nice to meet you")

_my_func_greet()

# Que 3: What is the difference between return and print statement.
Return : 
(1) It is used to exit a function and return a value.
(2) It returns a value that can be assigned to a variable or used in any expression.
(3) It can be used multiple times in a function but only one value can be returned at a time.
(4) Exiting the function with return ends the function and control returns to calling code.

Print:
(1) It is used to display output to the console.
(2) It displays output to the console but does not return the value.
(3) It can be used multiple times in a function but does not affect the function’s return value.
(4) The print does not affect program flow and execution continues normally.

# Que 4: What are *args and **kwargs?
*args is known as variable length argument which means that it allows a function to accept any number of positional arguments i.e. arguments that are non-keyword arguments.
If we are not sure about the numbers of paramets t pass through a function then we can use *args.

**kwargs allows us to pass a variable number of keyworded arguments to the function.
*args has limitation to not accept data as dictionary , in that case **kwargs can be used to pass keywords and associated data values of keywords through a function.

# Que 5: What is iterator ?
An iterator is an object that can be iterated upon, meaning that you can traverse through all the values.
It has methods __iter__() and __next__().
__iter__(): Called to initialize the iterator. It must return an iterator object.
__next__(): Called to iterate over the iterator. It must return the next value in the data stream.

# Que 6 : Write a code to generate square root of number from 1 to n using generator.
def square_num (num):
  for i in range (1,num+1):
   yield i ** 2
    
num = int(input("Enter Number: "))
Gen_Sq = square_num(num)
for i,square_root in enumerate(Gen_Sq):
  print(square_root)

# Que 7 : Write a code to that generated palindromic numbers upto n using a generator.


# Que 8 : Write a code that generates even numbers from 2 to n using a generator.

def even_num (num):
  for i in range (2,num+1):
    if i%2 == 0:
      yield i
    
num = int(input("Enter Number: "))
Gen_even = even_num(num)
for i,even_number in enumerate(Gen_even):
  print(even_number)

#Que 9 : Write a code that generates powers of two up to n using a generator.

def display_powers_of_2(exp):
    for i in range(exp+1):
        yield 2**i

# Que 10 : Write a code that generates prime numbers upto n using a generator.

def prime_number(num):
    for i in range(2,num):
      if num%i == 0 :
        return False
    return True
        
def _prime (num1):
  for i in range(2,num1):
    if prime_number(i):
      yield i

num1 = int(input("Enter the limit to check whether number is prime: "))

gen_prime = _prime(num1)
for i,prime_print in enumerate(gen_prime):
  print(prime_print)

        

exp = int(input("Enter the number of powers of 2 to display: "))
gen_pow = display_powers_of_2(exp)
for i,power in enumerate(gen_pow):
  print(power)

# Que 11: Write a lamba function to calculate sum of two numbers.


x = int(input("Enter num1: "))
y = int(input("Enter num2: "))

_SUM =  lambda x,y: x+y
_result = _SUM(x,y)
print("The sum of the two numbers is:",_result)

# Que 12: Write a lamba function to calculate square of given number.

num = int(input("Enter num: "))

_Square = lambda num: num*num
_square_result = _Square(num)
print("The square of a given number is:",_square_result)

# Que 13: Write a lamba function to check whether given number is even or odd.

num = int(input("Enter num: "))

_check_even_odd = lambda num: print("The given number is even:",num) if num%2 == 0 else print("The given number is odd:",num)
_check_even_odd_result = _check_even_odd(num)

# Que 14: Write a lamba function to concate two strings.

_str1 = input("Enter string 1: ")
_str2 = input("Enter string 2: ")

_concate_str = lambda _str1,_str2: _str1 + _str2
_concate_str_result = _concate_str(_str1,_str2)
print("The concatenated string is:",_concate_str_result)

# Que 15: Write a lamba function to find maximum of three given numbers.

_num1 = int(input("Enter num 1: "))
_num2 = int(input("Enter num 2: "))
_num3 = int(input("Enter num 3: "))

_Max_Num = lambda _num1,_num2,_num3: max(_num1,_num2,_num3)
_result_max_num = _Max_Num(_num1,_num2,_num3)
print("The maximum number is:",_result_max_num)

# Que 16: Write a code that generates the squares of even numbers from a given list.

_list_even =[]

def _check_of_even_num(_list):
  for i in _list:
    if i%2 == 0:
      _list_even.append(i)
  print(list(map(lambda x:x**2,_list_even)))
    
_check_of_even_num(
   _list = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]
)

# Que 17: Write a code that calculates the product of positive numbers from a given list.
from functools import reduce
_list_pos =[]

def _check_of_pos_num(_list):
  for i in _list:
    if i>0:
      _list_pos.append(i)
  print("The product of positive numbers from given list:",reduce((lambda x, y: x * y), _list_pos))

    
_check_of_pos_num(
   _list = [-1,2,3,2,4,-7]
)

# Que 18: Write a code that doubles the values of odd numbers from a given list.
_list_odd =[]

def _check_of_odd_num(_list):
  for i in _list:
    if i%2 != 0:
      _list_odd.append(i)
  print("The double of odd numbers in given list:",list(map(lambda x:x*2,_list_odd)))

    
_check_of_odd_num(
   _list = [2,3,4,5,6,7,8,9,11]
)

# Que 19: Write a code that calculates the sum of cubes of number from a given list.
from functools import reduce

def _check_of_cube_num(_list):
  _cubes_num = list(map(lambda x:x**3,_list))
  print("The cube of numbers in a list:",_cubes_num)
  _sum_num = reduce((lambda x,y: x+y),_cubes_num)
  print("The sum of cubes from a list:",_sum_num)

    
_check_of_cube_num(
   _list = [1,2,3,4,5]
)

# Que 20: Write a code that filters out prime numbers from a given list.
_list_prime = [2,3,6,5,8,9,7]
def is_prime(x):
  for i in range(2,x):
    if x%i ==0:
      return False
  return True

prime_numbers = list(filter(is_prime, _list_prime))
print(prime_numbers)

# Que 21: Write a lamba function to calculate sum of two numbers.


x = int(input("Enter num1: "))
y = int(input("Enter num2: "))

_SUM =  lambda x,y: x+y
_result = _SUM(x,y)
print("The sum of the two numbers is:",_result)

# Que 22: Write a lamba function to calculate sqaure of given numbers.


x = int(input("Enter num: "))

_Square=  lambda x: x*x
_result = _Square(x)
print("The square of the given numbers is:",_result)

# Que 23: Write a lamba function to check whether given number is even or odd.

num = int(input("Enter num: "))

_check_even_odd = lambda num: print("The given number is even:",num) if num%2 == 0 else print("The given number is odd:",num)
_check_even_odd_result = _check_even_odd(num)

# Que 24: Write a lamba function to concate two strings.

_str1 = input("Enter string 1: ")
_str2 = input("Enter string 2: ")

_concate_str = lambda _str1,_str2: _str1 + _str2
_concate_str_result = _concate_str(_str1,_str2)
print("The concatenated string is:",_concate_str_result)

# Que 25: Write a lamba function to find maximum of three given numbers.

_num1 = int(input("Enter num 1: "))
_num2 = int(input("Enter num 2: "))
_num3 = int(input("Enter num 3: "))

_Max_Num = lambda _num1,_num2,_num3: max(_num1,_num2,_num3)
_result_max_num = _Max_Num(_num1,_num2,_num3)
print("The maximum number is:",_result_max_num)

# Que 26: What is encapsulation in oops?

Encapsulation is one of the fundamental concepts in object-oriented programming (OOP).
It describes the idea of wrapping data and the methods that work on data within one unit.
This puts restrictions on accessing variables and methods directly and can prevent the accidental modification of data.
To prevent accidental change, an object’s variable can only be changed by an object’s method.
Those types of variables are known as private variables.

# Que 27: Explain the use of access modifiers in python classes.

Access modifiers are defined as an important part of the visibility and accessibility of data members in the field of object-oriented programming.
Access modifiers help to define how classes, methods, and variables can be accessed and modified by using access modifiers.
Python used the ‘_’ symbol to define the accessibility and control of data members of the class.
Access modifiers play a crucial role in maintaining data security and preventing unauthorized modifications.

Types:
Public Access Modifier: The members defined in the public class can be accessed from anywhere. 
Protected Access Modifier: The members defined in the protected class can only be accessed from within the class in which they are declared and by its subclasses. 
Private Access Modifier: The members defined in the private class can only be accessed by class members.

# Que 28: What is inheritance in oops?

Inheritance is one of the core features of object-oriented programming. 
It’s a programming procedure that allows you to reuse code by referencing the behaviors and data of an object. 
In other words, a class that inherits from another class shares all the attributes and methods of the referenced class.

Types:

(1) Single Inheritance:
one class inherits from only one parent class. 
This is also called simple inheritance because it’s the simplest type of inheritance you can use.

(2) Hierarchical Inheritance
The inheritance in which a single base class inherits multiple derived classes is known as the Hierarchical Inheritance. 
This inheritance has a tree-like structure since every class acts as a base class for one or more child classes. 
The visibility mode for each derived class is specified separately during the inheritance and it accesses the data members accordingly.
An inherited class is called a subclass or child class of the class it inherits from. 
And the class being inherited is called either a parent class, superclass, or base class.

(3) Multilevel Inheritance
The inheritance in which a class can be derived from another derived class is known as Multilevel Inheritance.
Suppose there are three classes A, B, and C. A is the base class that derives from class B. 
So, B is the derived class of A. Now, C is the class that is derived from class B.
This makes class B, the base class for class C but is the derived class of class A. 
This scenario is known as the Multilevel Inheritance. 
The data members of each respective base class are accessed by their respective derived classes according to the specified visibility modes.

(4) Multiple Inheritance
The inheritance in which a class can inherit or derive the characteristics of multiple classes, or a derived class can have over one base class, is known as Multiple Inheritance. 
It specifies access specifiers separately for all the base classes at the time of inheritance. 
The derived class can derive the joint features of all these classes and the data members of all the base classes are accessed by the derived or child class according to the access specifiers. 

# Que 29: Define polymorphism in oops?

Polymorphism is the ability of any data to be processed in more than one form.
The word itself indicates the meaning as poly means many and morphism means types. 
Polymorphism is one of the most important concepts of object-oriented programming languages. 
The most common use of polymorphism in object-oriented programming occurs when a parent class reference is used to refer to a child class object.

# Que 30: Explain method overriding in python?

Method overriding is an ability of any object-oriented programming language that allows a subclass or child class to provide a specific implementation of a method that is already provided by one of its super-classes or parent classes. 
When a method in a subclass has the same name, same parameters or signature and same return type(or sub-type) as a method in its super-class, then the method in the subclass is said to override the method in the super-class.
(child class is always poerful than parent class)
